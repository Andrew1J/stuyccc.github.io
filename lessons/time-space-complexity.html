<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Time and Space Complexity</title>

<!--Codemirror imports-->
<script src="/static/codemirror.js"></script>
<script src="/static/simplescrollbars.js"></script>
<link rel="stylesheet" href="/static/codemirror.css">
<link rel="stylesheet" href="/static/simplescrollbars.css">
<link rel="stylesheet" href="/static/one-theme.css">
<script src="/static/highlight/python.js"></script>
<script src="/static/highlight/markdown.js"></script>
<!--Marked - Markdown Renderer-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/1.1.1/marked.min.js"></script>
<!--Pyodide imports-->
<script src="https://pyodide-cdn2.iodide.io/v0.15.0/full/pyodide.js"></script>
<script src="/static/pyodideWrapper.js"></script>
<script src="/static/cellManager.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Fira+Mono:wght@300;400&family=Fira+Sans:wght@300;400;500&display=swap"
  rel="stylesheet">
<script>
  cellManager = new CellManager();
  window.toggleMarkdownCell = function (e) {
    e.parentNode.querySelector('.Cell-MarkdownSource').style.display = '';
    e.parentNode.querySelector('.CodeMirror').CodeMirror.refresh();
    e.style.display = 'none';
  }
</script>
<link rel="stylesheet" href="/static/main.css">
<style type="text/css">
  a.anchor-link {
     display: none;
  }
  </style>
</script>

</head>
<body class="jp-Notebook" data-jp-theme-light="true" data-jp-theme-name="JupyterLab Light">
  <div class="Cell-container">

<div class="Cell" data-type="markdown">
<div class="Cell-input"><div class="Cell-input-actions"></div><div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor Cell-MarkdownSource" data-type="inline" style="display: none;">
    <textarea class="CodeMirror-textarea" data-mime-type="text/x-markdown"># Time and Space Complexity  
`Lessons[0]`  
*This document contains runnable python examples. You may edit and run code blocks by pressing `Shift-Enter`*

---
#### What is Time Complexity?
Time complexity is a function describing the amount of time an algorithm takes in terms of the amount of input to the algorithm. Time complexity is usually defined using "Big O notation" - The upper and lower bounds of the number of operations taken. In other words, you can use Big-O notation to estimate the upper, lower and average number of operations taken. 

Big O Notation ignores coeffiecient, and only takes into account the leading term:
```
O(2N)→O(N)
O(N² +3N + 4)→O(N²)
```
`N` refers to the input size of the algorithm, though sometimes other variables are introduced, depending on the algorithm being measured, and the problem at hand.  
  
By calculating the time complexity of an algorithm, it is possible to check if an algorithm is efficient enough for the problem. For example, if a problem has an input with size of `N=10⁵`, it is reasonable to assume that the expected algorithm runs in `O(N)` or `O(NlogN)` rather than something much more complex.

#### Examples of specific time complexities
Constant time is notated as `O(1)`, and does not depend on the size of the input, `N`:</textarea>
</div>
<div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput " data-mime-type="text/markdown" ondblclick="toggleMarkdownCell(this)"><h1 id="Time-and-Space-Complexity">Time and Space Complexity<a class="anchor-link" href="#Time-and-Space-Complexity">&#182;</a></h1><p><code>Lessons[0]</code><br>
<em>This document contains runnable python examples. You may edit and run code blocks by pressing <code>Shift-Enter</code></em></p>
<hr>
<h4 id="What-is-Time-Complexity?">What is Time Complexity?<a class="anchor-link" href="#What-is-Time-Complexity?">&#182;</a></h4><p>Time complexity is a function describing the amount of time an algorithm takes in terms of the amount of input to the algorithm. Time complexity is usually defined using "Big O notation" - The upper and lower bounds of the number of operations taken. In other words, you can use Big-O notation to estimate the upper, lower and average number of operations taken.</p>
<p>Big O Notation ignores coeffiecient, and only takes into account the leading term:</p>

<pre><code>O(2N)→O(N)
O(N² +3N + 4)→O(N²)</code></pre>
<p><code>N</code> refers to the input size of the algorithm, though sometimes other variables are introduced, depending on the algorithm being measured, and the problem at hand.</p>
<p>By calculating the time complexity of an algorithm, it is possible to check if an algorithm is efficient enough for the problem. For example, if a problem has an input with size of <code>N=10⁵</code>, it is reasonable to assume that the expected algorithm runs in <code>O(N)</code> or <code>O(NlogN)</code> rather than something much more complex.</p>
<h4 id="Examples-of-specific-time-complexities">Examples of specific time complexities<a class="anchor-link" href="#Examples-of-specific-time-complexities">&#182;</a></h4><p>Constant time is notated as <code>O(1)</code>, and does not depend on the size of the input, <code>N</code>:</p>
</div>
</div>
</div><div class="Cell Code-cell   " data-type="python">
<div class="Cell-input">
<div class="Cell-input-actions">
    <button class="Code-cell-run" onclick="cellManager.handleRunCommand(this)">
        <h3>Run</h3>
    </button>
</div>
<div class="jp-CodeMirrorEditor jp-Editor Input-editor" data-type="inline">
     <textarea class="CodeMirror-textarea" data-mime-type="text/x-python">x = [3,1,4,7,-1,5,0]
x[3] # A Constant time operation, try changing the index and re-running this block to see how you can run it yourself!</textarea>
</div>
</div>

<div class="Cell-output">




    




<div class="jp-RenderedText jp-OutputArea-output jp-OutputArea-executeResult" data-mime-type="text/plain">
<pre>7</pre>
</div>



</div>

</div>
<div class="Cell" data-type="markdown">
<div class="Cell-input"><div class="Cell-input-actions"></div><div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor Cell-MarkdownSource" data-type="inline" style="display: none;">
    <textarea class="CodeMirror-textarea" data-mime-type="text/x-markdown">`O(N)`, or Linear, is when an algorithm scales linearly with input size:</textarea>
</div>
<div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput " data-mime-type="text/markdown" ondblclick="toggleMarkdownCell(this)"><p><code>O(N)</code>, or Linear, is when an algorithm scales linearly with input size:</p>
</div>
</div>
</div><div class="Cell Code-cell   " data-type="python">
<div class="Cell-input">
<div class="Cell-input-actions">
    <button class="Code-cell-run" onclick="cellManager.handleRunCommand(this)">
        <h3>Run</h3>
    </button>
</div>
<div class="jp-CodeMirrorEditor jp-Editor Input-editor" data-type="inline">
     <textarea class="CodeMirror-textarea" data-mime-type="text/x-python">#This function runs in linear time to find a value in an input array, and return its index:
def linear_search(value_to_find, array):
    for i,val in enumerate(array):
        if val==value_to_find:
            return i
    #Value was not found
    return -1
print('There is a 7 at index:',linear_search(7,x))</textarea>
</div>
</div>

<div class="Cell-output">




    


<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain">
<pre>There is a 7 at index: 3
</pre>
</div>


</div>

</div>
<div class="Cell" data-type="markdown">
<div class="Cell-input"><div class="Cell-input-actions"></div><div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor Cell-MarkdownSource" data-type="inline" style="display: none;">
    <textarea class="CodeMirror-textarea" data-mime-type="text/x-markdown">`O(logN)` is the notation for logarithmic functions. Generally the `log` will have a base of 2. A common example of this is binary search, which works by recursively slicing an array into halves to find a value. If you don't understand the algorithm, don't worry we'll be going over it later.</textarea>
</div>
<div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput " data-mime-type="text/markdown" ondblclick="toggleMarkdownCell(this)"><p><code>O(logN)</code> is the notation for logarithmic functions. Generally the <code>log</code> will have a base of 2. A common example of this is binary search, which works by recursively slicing an array into halves to find a value. If you don't understand the algorithm, don't worry we'll be going over it later.</p>
</div>
</div>
</div><div class="Cell Code-cell   " data-type="python">
<div class="Cell-input">
<div class="Cell-input-actions">
    <button class="Code-cell-run" onclick="cellManager.handleRunCommand(this)">
        <h3>Run</h3>
    </button>
</div>
<div class="jp-CodeMirrorEditor jp-Editor Input-editor" data-type="inline">
     <textarea class="CodeMirror-textarea" data-mime-type="text/x-python">#This function runs in logarithmic time to find a value in a sorted input array, and return its index:
def binary_search(value_to_find, array):
    mid = 0
    start = 0
    end = len(array)
    while end>=start:
        mid = (start+end)//2
        if array[mid]==value_to_find:
            return mid
        if value_to_find < array[mid]:
            end = mid - 1
        else:
            start = mid + 1
    #Value was not found
    return -1
x = sorted(x)
print(x)
print('There is a 1 at index:',binary_search(1,x))</textarea>
</div>
</div>

<div class="Cell-output">




    


<div class="jp-RenderedText jp-OutputArea-output" data-mime-type="text/plain">
<pre>[-1, 0, 1, 3, 4, 5, 7]
There is a 1 at index: 2
</pre>
</div>


</div>

</div>
<div class="Cell" data-type="markdown">
<div class="Cell-input"><div class="Cell-input-actions"></div><div class="jp-CodeMirrorEditor jp-Editor jp-InputArea-editor Cell-MarkdownSource" data-type="inline" style="display: none;">
    <textarea class="CodeMirror-textarea" data-mime-type="text/x-markdown">Below we've made a table of the most common Time Complexities:  

| Notation | Description |
| --- | --- |
| `O(1)` | Constant, e.g. Accessing an array |
| `O(N)` | Linear, e.g. Iterating through a list |
| `O(logN)` | Logarithmic, e.g. Binary Search |
| `O(NlogN)` | Linearithmic, e.g. Merge Sort |
| `O(N^k)` | Polynomial, e.g. nested `for` loops |
| `O(k^N)` | Exponential, e.g. Finding all subsets of a list |
| `O(N!)` | Factorial, e.g. All permutations of a string |

#### Space Complexity
Space complexity is nearly exactly the same as time complexity, in terms of notation. However, space complexity refers to the amount of memory an algorithm uses over the course of execution, rather than the number of operations that are undertaken. For example, a fibonacci sequence only needs the previous two numbers, since this is a constant number, it is `O(N)`. However, a sort operation needs `O(N)` memory, or more, to store the array.  

That's it for this lesson. As always, if you have any feedback feel free to contact one of the instructors, or email stuyccc@gmail.com</textarea>
</div>
<div class="jp-RenderedHTMLCommon jp-RenderedMarkdown jp-MarkdownOutput " data-mime-type="text/markdown" ondblclick="toggleMarkdownCell(this)"><p>Below we've made a table of the most common Time Complexities:</p>
<table>
<thead><tr>
<th>Notation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O(1)</code></td>
<td>Constant, e.g. Accessing an array</td>
</tr>
<tr>
<td><code>O(N)</code></td>
<td>Linear, e.g. Iterating through a list</td>
</tr>
<tr>
<td><code>O(logN)</code></td>
<td>Logarithmic, e.g. Binary Search</td>
</tr>
<tr>
<td><code>O(NlogN)</code></td>
<td>Linearithmic, e.g. Merge Sort</td>
</tr>
<tr>
<td><code>O(N^k)</code></td>
<td>Polynomial, e.g. nested <code>for</code> loops</td>
</tr>
<tr>
<td><code>O(k^N)</code></td>
<td>Exponential, e.g. Finding all subsets of a list</td>
</tr>
<tr>
<td><code>O(N!)</code></td>
<td>Factorial, e.g. All permutations of a string</td>
</tr>
</tbody>
</table>
<h4 id="Space-Complexity">Space Complexity<a class="anchor-link" href="#Space-Complexity">&#182;</a></h4><p>Space complexity is nearly exactly the same as time complexity, in terms of notation. However, space complexity refers to the amount of memory an algorithm uses over the course of execution, rather than the number of operations that are undertaken. For example, a fibonacci sequence only needs the previous two numbers, since this is a constant number, it is <code>O(N)</code>. However, a sort operation needs <code>O(N)</code> memory, or more, to store the array.</p>
<p>That's it for this lesson. As always, if you have any feedback feel free to contact one of the instructors, or email stuyccc@gmail.com</p>
</div>
</div>
</div>
  </div>
</body>








<script>
  // Creates the code editor from a target textarea using the CodeMirror library.
  var codeCells = document.getElementsByClassName("CodeMirror-textarea");
  for (var i = 0; i < codeCells.length; i++) {
    var editor = CodeMirror.fromTextArea(codeCells.item(i), {
      mode: {
        name: codeCells.item(i).dataset["mimeType"],
        version: 3,
        singleLineStringErrors: false,
        fencedCodeBlockDefaultMode: 'python'
      },
      extraKeys: {
        'Tab': function (cm) {
          var spaces = Array(cm.getOption("indentUnit") + 1).join(" ");
          cm.replaceSelection(spaces);
        },
        'Shift-Enter': function (cm) {
          cellManager.handleRunCommand(cm.getWrapperElement());
        },
      },
      indentUnit: 4,
      matchBrackets: true,
      theme: 'one-theme',
      scrollbarStyle: 'overlay',
      viewportMargin: Infinity,
      lineNumbers: true,
    });
  }/*
    var md = document.getElementsByClassName("Cell-MarkdownSource");
    for (var i = 0; i < md.length; i++) {
      md2html = marked(md.item(i).querySelector('pre').textContent);
      md.item(i).parentElement.querySelector('.jp-RenderedMarkdown').innerHTML=md2html;
    }*/
</script>
</html>
