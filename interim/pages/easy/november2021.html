<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="../template.css" type="text/css">
    <link rel="icon" href="../../data/favicon.ico">

    <!--KaTeX in <script type="math/tex"> tags -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/mathtex-script-type.min.js" integrity="sha384-lfASb0Jhxn21qr4pih+Mx6uK2+JEKTtnpMnsCo+PTmb3n/iSUhox6v7eGkBfi47O" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="../../data/gruvbox-dark-pale.min.css">
    <script src="../../data/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>StuyCCC</title>
</head>
<body>
    <div id="side">
        <div id="icon">
            <h1><a href="../../../index.html">
                <img class="logo" src="../../data/CCCLogo.png" alt="CCC logo" width="142px">
            </a></h1>
        </div>
        <br>
        <p><a href="../about.html">about</a></p>
        <p><a href="../calendar.html">calendar</a></p>
        <p><a href="../lessons.html">lessons</a></p>
        <p><a href="../problems.html">problems</a></p>
        <p><a href="../resources.html">resources</a></p>
    </div>
    <div id="main">
        <h4>Last Updated 2021-11-13</h4>
        <fieldset>
            <legend>EASY NOVEMBER 2021</legend>
            <!-- use <script type="math/tex"> to use latex
                and <pre><code class="language-cpp"> (or whatever language) for code-->
            <a href="https://codeforces.com/problemset/problem/1260/A">Problem 12</a>
            <details>
                <summary>Solution</summary>
                <p>The optimal strategy for this problem is to make all the heater have close to the same number of sections. You can see this by realizing (x-1)^2 + 1^2 > (x/2)^2 + (x/2)^2. So now we have "sum" sections and "c" heaters and we need to find the optimal way to split sum into c numbers such that the c numbers are really close together. We can do this by having sum%c heaters with value of sum/c + 1, and having the rest be sum/c. This adds up to sum, and keeps the c heaters close together. Now with this distribution our final anwer becomes (sum%c)*(sum/c+1)*(sum/c+1) + (c-sum%c)*(sum/c)*(sum/c).</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1245/A">Problem 11</a>
            <details>
                <summary>Solution</summary>
                <p>First observation to solve this problem is to realize that all multiples of a and b are painted white (ie anything with the form ax or by, where x,y are integers will be painted white). From there we can realize that anything in the form ax+by will also be painted white, because ax is painted white and ax is by (multiple of b) away from ax+by, so ax+by is also white. Now notice that ax+by is a multiple of gcd(a,b). I won't prove this fact, but just know that any number greater than ab and is a multiple of gcd(a,b) can be written as ax+by (try some examples in your head).</p>
                <p>So this means that if gcd(a,b) = 1, then the result would be finite because every number greater than ab would be white, which would leave a finite number of black spots in the range [0,ab]. Now if gcd(a,b) != 1, then there would be numbers greater than ab that aren't painted white, and since we are going off to infinity, this means that there would be an infinite number of black numbers.</p>
                <p>Notice we can check the gcd of two numbers using the c++ library function __gcd(a,b). If __gcd(a,b) == 1 print "Finite", else print "Infinite".</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1008/B">Problem 10</a>
            <details>
                <summary>Solution</summary>
                <p>The optimal strategy for this problem is for a current rectangle it is optimal to orientate it in such a way that its height is maximal but not greater than the previous rectangle. This is optimal because if the current height is larger than its more likely that the next rectangle is shorter than it. The way to program this optimal strategy is to first create a max = max(width, height) of first rectangle, and then for every rectangle afterward, set the max to the largest side that is still smaller than or equal to the max. If this is not possible for all rectangles print NO else print YES. </p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1411/B">Problem 09</a>
            <details>
                <summary>Solution</summary>
                <p>Notice that we only have to consider digits, so 1-9, so notice that the lcm of of the first 9 digits is 2520. This means that any multiple of 2520 is definitely fair, and this means that the most we have to loop from x to find the next number is 2520, because after 2520 iterations we will find a multiple of 2520 that most definitely works. So now that we know our for loop won't time out (2520 * 10^3 works fast enough), we can just do a for loop from x and increment by 1 until we find a fair number, and then return that fair number.</p>
                <p>Now I'll explain how to check if a number is a fair. To get the digits of the number we can make a copy of it and then repeatedly modulo it by 10 and then divide it by 10 until we get 0. For example 282 modulo 10 = 2, divide it by 10 and you get 28, 28 modulo 10 = 8, divide it by 10 and you get 2, 2 modulo 10 = 2, and we have gotten all our digits (note this works because of integer division). Then we can just check if our original number is divisible by all these digits that we have gotten to see if its fair.</p>
            </details>
            <br>
            <a href="https://codeforces.com/problemset/problem/1342/A">Problem 08</a>
            <details>
                <summary>Solution</summary>
                <p>Notice that the second operation just performs the first operation twice, but does it in one move. So from this fact we can see that if 2a <= b, then it performing the second operation is not optimal at all, so we just perform the first operation the entire time to get a final answer of (x+y)*a. However if 2a > b, then it is optimal to use the second operation as much as possible, but we also don't want to make one of the numbers go below 0 because this wastes an extra move going back up, so our answer becomes min(x,y)*b+(max(x,y)-min(x,y))*a.</p>
            </details>
            <br>
            <a href="http://www.usaco.org/index.php?page=viewproblem2&cpid=1084">Problem 07</a>
            <details>
                <summary>Solution</summary>
                <p>WILL BE HERE SOON</p>
            </details>
            <br>
            <a href="https://codeforces.com/gym/352982/problem/A1">Problem 06</a>
            <details>
                <summary>Solution</summary>
                <p>There are several ways to solve this problem, but I'll explain the jury's linear solution. You can first create an array size n+1, so you can work with every day 1-indexed. Then, you can create another array with the same length that stores the number of bones broken on the i'th day. Now, you can simulate. On the 0-th day you will have k bones. For every day after that, the number of bones will be equal to the number of bones on the previous day minus the bones broken on that day. If he did not break any bones and has less than k bones he will regenerate one. The first time the bone count hits below or equal to zero, print the day number and exit your program.</p>
            </details>
            <br>
            <a href="http://usaco.org/index.php?page=viewproblem2&cpid=1085">Problem 05</a>
            <details>
                <summary>Solution</summary>
                <p>First, you can sort the stall height limits in ascending order. For every stall, check how many cows could fit in that stall. Notice that for the b_i-th stall, if there are x_i cows that could fit, then all of those cows could have also fit in a previous stall. So in order for every stall to have a cow, i-1 of those cows must have already gone to an earlier stall. Thus, the final answer is x_1*(x_2-1)*(x_3-2)*...</p>
            </details>
            <br>
            <a href="http://www.usaco.org/index.php?page=viewproblem2&cpid=835">Problem 04</a>
            <details>
                <summary>Solution</summary>
                <p>One quick way of doing this problem is to sort the cows in reverse order(descending). From here just loop through the array, and whenever the cow’s waiting tolerance is greater than or equal to its index, increment the answer by 1. You can also break whenever you find a cow that doesn’t satisfy this condition, but this is not needed.</p>
            </details>
            <br>
            <a href="http://www.usaco.org/index.php?page=viewproblem2&cpid=1011">Problem 03</a>
            <details>
                <summary>Solution</summary>
                <p>We can first loop over all triples of pastures. As one of the fence posts is parallel to the x-axis and the other is parallel to the y-axis, then the triangle formed must be right. For a triangle to be right in this scenario, two of the y-coordinates of the points must be the same and two of the x-coordinates must be the same. Once you have validated a triangle, compute double the area by using the base*formula for a triangle (no dividing by 2). Take the max of all areas to get the final answer.</p>
            </details>
            <br>
            <a href="http://usaco.org/index.php?page=viewproblem2&cpid=1107">Problem 02</a>
            <details>
                <summary>Solution</summary>
                <p>For every cow, instead of keeping track of their year, try to keep track of their cycle value relative to Bessie. To make things simpler, suppose that Bessie was born on cycle 0. Still, we need to parse the input properly. We can simply split each string by spaces and only look at the 1st,4th,5th, and 8th words as they are the only ones that provide any valuable information. While parsing the input, we can assign each cow its cycle. Suppose that the second cow mentioned was born on cycle C. There are four cases: either the new cow was born in the same cycle but on an earlier year (lower index in the array [Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig, Rat]), it is in the same cycle but on a later year, it is in the cycle directly before C, and it is in the cycle directly after C. After this we can split the computation into two parts: the cycle difference and  the year difference. The cycle difference between Bessie and Elsie is just abs(C1-C2)*12 and the year difference is the difference of their indices in the array. Here we can add the value to the cycle difference or subtract, depending on Elsie if was born earlier.</p>
            </details>
            <br>
            <a href="http://www.usaco.org/index.php?page=viewproblem2&cpid=966">Problem 01</a>
            <details>
                <summary>Solution</summary>
                <p>Here a simple simulation will be too slow. Instead, notice that the pattern of numbers and Moos repeats every 15 numbers. In other words, every number with a value mod 15 that isn't a multiple of 3 or 5, will be itself in the sequence. There are eight such residues, so for every interval of 15 there are eight valid numbers. So you can simply add n*15/8 (to skip past the previous sets of 15 numbers) and add what the mod 8th number in the sequence is. Notice that the 15 value is not a number, so when N divides 8, subtract 1 from the expression.</p>
            </details>
        </fieldset>
    </div>
</body>
