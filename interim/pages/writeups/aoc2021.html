<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="../../templates/template.css" type="text/css">
    <link rel="icon" href="../../templates/favicon.ico">
    <script src="../../templates/template.js"></script>

    <!--KaTeX in <script type="math/tex"> tags -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/mathtex-script-type.min.js" integrity="sha384-lfASb0Jhxn21qr4pih+Mx6uK2+JEKTtnpMnsCo+PTmb3n/iSUhox6v7eGkBfi47O" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="../../templates/gruvbox-dark-pale.min.css">
    <script src="../../templates/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>StuyCCC</title>
</head>
<body>
    <div id="side"></div>
    <div id="main">
        <h4>Last Updated 2021-12-04</h4>
        <fieldset>
            <legend>ADVENT OF CODE 2021</legend>
            <!-- use <script type="math/tex"> to use latex
                and <pre><code class="language-cpp"> (or whatever language) for code-->
            <h2><a href="https://adventofcode.com/2021/day/1">Problem 01</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code class="language-python">
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [int(line.strip()) for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    cnt = 0;
    for i in range(1, len(lines)):
        if (lines[i] > lines[i-1]):
            cnt += 1;
    return cnt;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>Well this first problem doesn't really need much explanation, just figure out how to read input from a file for your respective language. And then loop through the list you have gotten and if i != 0 and list[i] > list[i-1] increment the count. And at the end print the count.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code>
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [int(line.strip()) for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    cnt = 0;
    for i in range (3, len(lines)):
        if (lines[i] > lines[i-3]):
            cnt += 1;
    return cnt;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>Notice that when you are comparing two sets of three in for example the list [a,b,c,d] if we compare a+b+c and b+c+d we really are only comparing between a and d. So for this part we can just loop through the list and if i >= 3 and list[i] > list[i-3] increment the count, and at the end print the count.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/2">Problem 02</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code>
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [line.strip().split() for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    x,y = 0,0;
    for i in range(len(lines)):
        if (lines[i][0] == "forward"): x += int(lines[i][1]);
        if (lines[i][0] == "down"): y += int(lines[i][1]);
        if (lines[i][0] == "up"): y -= int(lines[i][1]);
    return x*y;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>The instructions for this problem is fairly simple, First read in the lines from the input file. Then initialize x and y to 0. Then for each line in the lines read, split them by the space and then if 1st part is "forward" increase x by the 2nd part, if 1st part is "down" increase y by the 2nd part, and if 1st part is "up" decrease y by the 2nd part. Finally at the end print x*y.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code>
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [line.strip().split() for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    x,y,a = 0,0,0;
    for i in range(len(lines)):
        if (lines[i][0] == "forward"):
            x += int(lines[i][1]);
            y += a * int(lines[i][1]);
        if (lines[i][0] == "down"): a += int(lines[i][1]);
        if (lines[i][0] == "up"): a -= int(lines[i][1]);
    return x*y;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>The instructions for this problem is fairly simple as well. First read in the lines from the input file. Then initialize x, y, and a to 0. Then for each line in the lines read, split them by the space and then if the 1st part is "forward" increase x by the 2nd part and increase y by a * 2nd part, if the 1st part is "down" decrease a by the 2nd part, and if the 1st part is "up" increase a by the 2nd part. Finally at the end print x*y.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/3">Problem 03</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code>
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    gamma = "";
    epsilon = "";
    lt = [0] * len(lines[0]);
    for line in lines:
        for i,x in enumerate(line):
            if (x == "1"): lt[i] += 1;
    for x in lt:
        if (x > len(lines)-x):
            gamma += "1";
            epsilon += "0";
        else:
            gamma += "0";
            epsilon += "1";
    return int(gamma, 2) * int(epsilon, 2);

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>First initialize two empty strings gamma and epsilon. For each position (from left to right) in the bit strings read, loop through the entire list keeping track of the number of 1s found in that certain position, lets call this number x. If x > len(lines) - x append a 1 to gamma and append a 0 to epsilon, else append a 0 to gamma and append a 1 to epsilon. After gamma and epsilon are the same size at the original bit strings convert them into integers and then multiple them, and return the answer.</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code>
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n")[0:-1]];
    fout.write(str(solve(lines)));

def solve(lines):
    cpy1 = [x for x in lines];
    cpy2 = [x for x in lines];
    for i in range(len(lines[0])):
        cnt = 0;
        for x in cpy1:
            if (x[i] == "1"): cnt += 1;
        if (cnt >= len(cpy1)-cnt): rem = "0";
        else: rem = "1";
        cpy1 = [x for x in cpy1 if x[i] != rem];
        if (len(cpy1) == 1): break;
    for i in range(len(lines[0])):
        cnt = 0;
        for x in cpy2:
            if (x[i] == "1"): cnt += 1;
        if (cnt >= len(cpy2)-cnt): rem = "1";
        else: rem = "0";
        cpy2 = [x for x in cpy2 if x[i] != rem];
        if (len(cpy2) == 1): break;
    return int(cpy1[0], 2) * int(cpy2[0], 2);

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>Again first initialize two copies of the list of lines read. Then for the first cpy loop through each bit position, i, and count the number of 1s, lets call it x. If x >= len(cpy1)-x loop set a char rem = '0' else rem = '1'. Loop through cpy1 again and remove all strings that have an ith bit that is not equal to rem. At the end of replacing if len(cpy1) == 1 break out of the loop. Do the same thing for cpy2 except switch the values for rem in the conditions. Finally convert the last elements in both copies to integers and print their multiple.</p>
            </details>

            <h2><a href="https://adventofcode.com/2021/day/4">Problem 04</a></h2>
            <details>
                <summary>Part 1</summary>
                <h3>Solution</h3>
                <pre><code>
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part1.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n\n")];
    lines = [[[int(x) for x in row.split()] for row in line.split("\n")] if i != 0 else [int(x) for x in line.split(",")] for i,line in enumerate(lines)];
    fout.write(str(solve(lines)));

def add(board, num):
    for i in range(5):
        for q in range(5):
            if (board[i][q] == num):
                board[i][q] = -1;
                break;
    return board;

def check(board):
    for i in range(5):
        good1,good2 = True,True;
        for q in range(5):
            if (board[i][q] != -1): good1 = False;
            if (board[q][i] != -1): good2 = False;
        if (good1 == True or good2 == True): return True;
    return False;

def sum(board):
    sum = 0;
    for i in range(5):
        for q in range(5):
            if (board[i][q] != -1): sum += board[i][q];
    return sum;

def solve(lines):
    for x in lines[0]:
        for board in lines[1:]:
            board = add(board, x);
            if (check(board)):
                return sum(board) * x;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>Some helpful things to do before we start, first notice that all the numbers given are positive so we can represent them as being reached by setting them to an impossible value like -1. Now create a check function that checks if in a given board if it completed (i.e. there are 5 -1's in a row or a column) and returns true if the board is completed. Also create an add function that goes through a board and looks for a certain number x, if that number is found it replaces it with -1 (ie saying that position has been found) and returns the board. Finally create a function that given a board sums all the values that aren't -1 (ie adding all numbers that aren't marked in a board).</p>
                <p>Now we have those helpful functions we can loop through the list of numbers in the order they are given and then loop through the boards using the add function to affect them. Directly after adding a number, check if the board is completed. If it is this means this board is the first one to be completed so we can just sum the remaining elements using sum and multiply it by the current number in the list of numbers and return the value (this ends the function and prevents double counting).</p>
            </details>
            <br>
            <details>
                <summary>Part 2</summary>
                <h3>Solution</h3>
                <pre><code>
# written by Mohammad Khan
fin = open("../Input.in", "r");
fout = open("../Part2.out", "w");

def main():
    lines = [line.strip() for line in fin.read().split("\n\n")];
    lines = [[[int(x) for x in row.split()] for row in line.split("\n")] if i != 0 else [int(x) for x in line.split(",")] for i,line in enumerate(lines)];
    fout.write(str(solve(lines)));

def add(board, num):
    for i in range(5):
        for q in range(5):
            if (board[i][q] == num):
                board[i][q] = -1;
                break;
    return board;

def check(board):
    for i in range(5):
        good1,good2 = True,True;
        for q in range(5):
            if (board[i][q] != -1): good1 = False;
            if (board[q][i] != -1): good2 = False;
        if (good1 == True or good2 == True): return True;
    return False;

def sum(board):
    sum = 0;
    for i in range(5):
        for q in range(5):
            if (board[i][q] != -1): sum += board[i][q];
    return sum;

def solve(lines):
    bad = set();
    for x in lines[0]:
        for i,board in enumerate(lines[1:]):
            board = add(board, x);
            if (check(board)):
                bad.add(i);
            if (len(bad) == len(lines)-1):
                return sum(board) * x;

main();
                </code></pre>
                <h3>Explanation</h3>
                <p>We are going to use the same helper functions as described in part 1, but our algorithm changes a bit. First initialize a set called "bad" which represents all the completed boards. We are first looping through the list of numbers given in order, and then loop through the boards like in part 1. Also add to the boards we loop through as well and check them, however this time if the check turns out to be true instead of ending the function we are going to add the index value of the board into the bad set. We are going to continue this process until the bad set reaches the same size as the number of boards given. Notice that the set is used to prevent overcounting of bad sets. Now when we see that the bad set is equal in size to the number of boards that means the board that just added to the bad set is the last board, so we can return the sum of this board times the current number.</p>
            </details>
        </fieldset>
    </div>
</body>
